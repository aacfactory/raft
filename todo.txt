***NODE***
节点之间通过quic通讯。
集群分为两层，高层为Leader和Candidate，低层为Follower
* 高层：数据写入与分发层，步骤为收到数据后找leader，有leader进行数据写入，并等待高层数据同步写入，然后再分发给低层。
* 低层：数据读取层，在加入集群之后，通过与集群返回的端点建立链接，开始接收数据。

***join和leave***
高层：类gossip的方式进行广播。
低层：只在高层内广播，单自身不进入广播系统。

步骤：
前提：列表是排序类型，可hash，且有同步锁
1、A收到B的加入请求，A把列表返回给B，B拿着A的列表对比B的列表，如果有新的，则B和新的进行加入，如果存在A里没有的，则把A里没有的给A。
2、低层与leader链接的发现leader宕机，则重新join，否则不join。

***投票***
启动
1、在集群刚启动后，节点间互相发起投票，投票过程为开启投票窗口（同一时期内，最早的窗口是有效的，且窗口的负责人为发起人）（成员无论谁收到窗口，都先判断窗口时间，如果早与之前投的，则再投）
2、成员在窗口内给出结果（之间的ping时长）
3、发起人判断当投票数满足最小规定后，取短的为leader，然后关闭窗口，层内广播谁是leader。
4、如果此时发生leader宕机，走leader宕机程序。
leader宕机（心跳错误）
1、无论谁发现都发起投票，走启动的程序。


在投票结束后，如果存在低层的，则leader给每一个低层分配一个与低层之间ping最短的节点，且一旦分配后，则移入下一个列表，以保证平均。

***LOG***
单独做顺序日志，块式读写。没有快照。
具备自校验

***FSM***
状态机
自定义数据行为，一个行为是一个事件，一个事件对应一条日志。

***事件***
事件的参数是[]BYTE，结果也是[]BYTE。
自身的存储是自身管理
事件的log具备分布式hash的顺序性，以提高性能。hash key为事件名，则一个事件名一个log。
事件提供channel，给client用于事件监听。
